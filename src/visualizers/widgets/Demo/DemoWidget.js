/*globals define, WebGMEGlobal*/

/**
 * Generated by VisualizerGenerator 1.7.0 from webgme on Tue Nov 24 2020 12:11:41 GMT-0600 (北美中部标准时间).
 */

define(['jointjs','css!./styles/DemoWidget.css','css!jointjscss'], function (jointjs) {
    'use strict';

    var WIDGET_CLASS = 'Demo';

    function DemoWidget(logger, container) {
        console.log(jointjs);
        this._logger = logger.fork('Widget');

        this._el = container;

        this.nodes = {};
        this._initialize();

        this._logger.debug('ctor finished');
    }

    DemoWidget.prototype._initialize = function () {
        var width = this._el.width(),
            height = this._el.height(),
            self = this;

        // set widget class
        this._el.addClass(WIDGET_CLASS);

        this._graph = null;
        this._paper = null;

        this._graph = new jointjs.dia.Graph;
        this._paper = new jointjs.dia.Paper({
            el: $(this._el),
            width: width,
            height: height,
            gridSize: 1,
            defaultAnchor: {name:'perpendicular'},
            defaultConnectionPoint: {name:'boundary'},
            model: this._graph
        });
        
        this._paper.setInteractivity(false);
        this._paper.removeTools();

        this._paper.on('element:pointerdown',function(elementView) {
            var currentElement = elementView.model;
            console.log(currentElement);
            if (currentElement.get('type') === 'pn.Transition') {
                if (IsThisTransitionEnable(currentElement,this._InplaceArc,this._OutplaceArc)) {
                    Fire(currentElement,this._InplaceArc,this._OutplaceArc);
                    CheckIsEnable(this._Transition,this._InplaceArc,this._OutplaceArc);
                }
                
            };
        });
        
        this._place = jointjs.dia.Element.define('network.Place',{
            attrs:{
                circle: {
                    r: 20,
                    'stroke-width':3,
                    stoke: '#000000',
                    fill: '#aabbaa',
                    cursor:'pointer'
                },
                text: {
                    'font-weight':'800',
                    'text-anchor':'middle',
                    'ref-x': .5,
                    'ref-y': -20,
                    'ref': 'circle',
                    cursor: 'pointer'
                },
                label:{
                    'font-weight':'400',
                    'text-anchor':'middle',
                    'ref-y': 20,
                    'ref': 'circle',
                    cursor: 'pointer'
                }
            }

        },{
            markup: [{
                tagName: 'circle',
                selector:'circle'
            },{
                tagName: 'text',
                selector:'text'
            },{
                tagName: 'text',
                selector:'label'
            }]
        }
        
        );
    };

    DemoWidget.prototype.onWidgetContainerResize = function (width, height) {
        this._logger.debug('Widget is resizing...');
        if (this._paper) {
            this._paper.setDimensions(width,height);
            this._paper.scaleContentToFit();
        }
    };

    // Adding/Removing/Updating items
    DemoWidget.prototype.addNode = function (desc) {
        //this.initNetwork();
    };

    DemoWidget.prototype.removeNode = function (gmeId) {
    };

    DemoWidget.prototype.updateNode = function (desc) {
    };

    // Actual simulator functions
    DemoWidget.prototype.initNetwork = function (component, classification) {

        const pn = jointjs.shapes.pn;
        const sd = jointjs.shapes.standard;

        //var nodeIds = descriptor.childrenIds;
        console.info('descriptor')
        console.info(component);
        var Place = []
        var Transition = []
        var InplaceArc = []
        var OutplaceArc = []
        var Place_location = []
        var Transition_location = []
        for (let ki = 0; ki < component['Place'].length; ki++) {
            let row = parseInt(ki / 4)
            let column = parseInt(ki % 4)
            let x_co = 100*(2*column+1)
            let y_co = 200*(row + 1)
            
            var place = new pn.Place({
                position: {x:x_co,y:y_co},
                attrs:{
                    '.label': {
                        'text': component['Place'][ki]['name'] + '-' + component['Place'][ki]['marking'],
                        'fill': '#3498DB',
                    },
                    '.root': {
                        'stroke':'#3498DB',
                        'stroke-width':3,
                    },
                    '.tokens > circle': {
                        'fill': '#3498DB'
                    }
                },
                tokens: parseInt(component['Place'][ki]['marking'])
            });
            Place.push(place);
            Place_location.push(component['Place'][ki]['path']);
        }

        for (let ki = 0; ki < component['Transition'].length; ki++) {
            let row = parseInt(ki / 3)
            let column = parseInt(ki % 3)
            let x_co = 100*(2*column+2) + 20
            let y_co = 200*(row + 1.5)

            var transition = new pn.Transition({
                position: {x:x_co,y:y_co},
                attrs:{
                    '.label': {
                        'text': component['Transition'][ki]['name'],
                        'fill': '#2ECC71 ',
                    },
                    '.root': {
                        'fill':'#2ECC71 ',
                        'stroke':'#2ECC71 ',
                    }
                },
            });
            Transition.push(transition);
            Transition_location.push(component['Transition'][ki]['path']);
        }
        
        //console.info(Place_location)
        //console.info(Transition_location)
    
        for (let ki = 0; ki < component['InplaceArc'].length; ki++) {
            var link = new sd.Link();
            link.source(Place[Place_location.indexOf(component['InplaceArc'][ki]['src'])]);
            link.target(Transition[Transition_location.indexOf(component['InplaceArc'][ki]['dst'])]);
            InplaceArc.push(link);
            }
        
        for (let ki = 0; ki < component['OutplaceArc'].length; ki++) {
            var link = new sd.Link();
            link.source(Transition[Transition_location.indexOf(component['OutplaceArc'][ki]['src'])]);
            link.target(Place[Place_location.indexOf(component['OutplaceArc'][ki]['dst'])]);
            OutplaceArc.push(link);
        }
        //console.info(InplaceArc)
        //console.info(OutplaceArc)

        this._paper._Place = Place;
        this._paper._Transition = Transition;
        this._paper._InplaceArc = InplaceArc;
        this._paper._OutplaceArc = OutplaceArc;

        this._graph.addCell(this._paper._Place);
        this._graph.addCell(this._paper._Transition);
        this._graph.addCell(this._paper._InplaceArc);
        this._graph.addCell(this._paper._OutplaceArc);

        //CheckIsEnable(this._paper._Transition, this._paper._InplaceArc, this._paper._OutplaceArc);
        setTimeout(()=>{CheckIsEnable(this._paper._Transition,this._paper._InplaceArc,this._paper._OutplaceArc);},100);
    };

    // Check whether the transitions is enable
    function CheckIsEnable(Transition, InplaceArc, OutplaceArc) {
        //console.info(Transition[0])
        //console.info(Transition[1])
        let notification = 0;

        for (let pi = 0; pi < Transition.length; pi++) {
            let transition = Transition[pi];
            if (IsThisTransitionEnable(transition,InplaceArc,OutplaceArc) === 0) {
                
                let color = transition.attributes.attrs['.root'].fill
                if (color !== '#707B7C'){
                transition.attr('.root/fill', '#707B7C');
                transition.attr('.root/stroke', '#707B7C');
                transition.attr('.label/fill', '#707B7C');   
                if (notification === 0 ){ 
                setTimeout(()=>{alert('The gray transition reaches a deadlock.');},100);};
                notification = 1;
                }
                }else{
                let name = transition.attributes
                transition.attr('.root/fill', '#2ECC71');
                transition.attr('.root/stroke', '#2ECC71');
                transition.attr('.label/fill', '#2ECC71'); 
                }
        };
    }

    function IsThisTransitionEnable(transition,InplaceArc,OutplaceArc) {

        let Inplace_count = 0;
        let Outplace_count = 0;

        let zero_token = 0;
        
        for (let ji = 0; ji < InplaceArc.length; ji++) {
            if (InplaceArc[ji].getTargetElement() === transition) {
                Inplace_count = Inplace_count + 1;
                let place = InplaceArc[ji].getSourceElement();
                if (place.get('tokens') == 0){
                    zero_token = zero_token + 1;
                }
            }    
        }
        for (let ji = 0; ji < OutplaceArc.length; ji++) {
            if (OutplaceArc[ji].getSourceElement() === transition){
                Outplace_count = Outplace_count + 1;
            }
        }

        if (Inplace_count > 0 && Outplace_count > 0 && zero_token === 0){
            return 1;
        }else{
            return 0;
        }
    };

    function Fire(transition,InplaceArc,OutplaceArc) {
        for (let ji = 0; ji < InplaceArc.length; ji++) {
            if (InplaceArc[ji].getTargetElement() === transition) {
                let place = InplaceArc[ji].getSourceElement()
                let token = place.get('tokens');
                token = token - 1;
                //InplaceArc[ji].getSourceElement().attr({tokens: token}); 
                place.set('tokens',token);
                }
            }    
        
        for (let ji = 0; ji < OutplaceArc.length; ji++) {
            if (OutplaceArc[ji].getSourceElement() === transition){
                let place = OutplaceArc[ji].getTargetElement()
                let token = place.get('tokens');
                token = token + 1;
                //InplaceArc[ji].getTargetElement().attr({tokens: token}); 
                place.set('tokens',token);
            }
        }
    }

    /* * * * * * * * Visualizer event handlers * * * * * * * */
    DemoWidget.prototype.onElementClick = function (elementView,event) {
        event.stopPropagation();
        console.log(elementView);
    };

    /* * * * * * * * Visualizer life cycle callbacks * * * * * * * */
    DemoWidget.prototype.destroy = function () {
    };

    DemoWidget.prototype.onActivate = function () {
        this._logger.debug('DemoWidget has been activated');
    };

    DemoWidget.prototype.onDeactivate = function () {
        this._logger.debug('DemoWidget has been deactivated');
    };

    return DemoWidget;
});
